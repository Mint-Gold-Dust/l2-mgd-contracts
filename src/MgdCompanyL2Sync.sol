// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.18;

import {MintGoldDustCompany} from "mgd-v2-contracts/marketplace/MintGoldDustCompany.sol";
import {MgdEIP712L2Sync, CrossAction, ECDSAUpgradeable} from "./utils/MgdEIP712L2Sync.sol";
import {ICrossDomainMessenger} from "./interfaces/ICrossDomainMessenger.sol";

/// @title MgdCompanyL2Sync
/// @notice An extension to {MintGoldDustCompany} containing functions that
/// syncs access levels management changes with a L2.
/// @author Mint Gold Dust LLC
/// @custom:contact klvh@mintgolddust.io
contract MgdCompanyL2Sync is MintGoldDustCompany, MgdEIP712L2Sync {
  /// @dev Emit when `setMessenger()` is called.
  event SetMessenger(address messenger);

  /**
   * @dev Emit for soft failing functions.
   * @param deadline of the signature
   */
  event ExpiredDeadline(uint256 deadline);

  /**
   * @dev Emit when `receiveL1Sync()` fails.
   * @param action intended
   * @param account address
   * @param state change
   */
  event FailedReceiveL1Sync(CrossAction action, address account, bool state);

  /// Custom errors
  error MgdCompanyL2Sync__performL2Call_noCrossDomainMGDCompany();
  error MGDCompanyL2Sync__onlyMainnet();
  error MGDCompanyL2Sync__notOnMainnet();

  ICrossDomainMessenger public messenger;

  modifier onlyCrossMessenger() {
    require(msg.sender == address(messenger));
    _;
  }

  /// @custom:oz-upgrades-unsafe-allow constructor
  constructor() {
    _disableInitializers();
  }

  /**
   * @notice Similar to `setValidator()` with L2 synchronizaton.
   * @param account to set as validator
   * @param state to be set
   * @param deadline for the syncing to occur via this `signature`
   * @param mgdSignature generated from this `publicKey()`
   * @dev Requirements:
   * - `mgdSignature` should be generated by `MintGoldDustCompany.publicKey()`
   * - This method should only be called from the L1 network
   */
  function setValidatorWithL2Sync(
    address account,
    bool state,
    uint256 deadline,
    bytes calldata mgdSignature
  )
    external
    onlyOwner
    isZeroAddress(account)
  {
    _onlyMainnet();
    _checkDeadline(deadline, true);

    bytes32 structHash =
      keccak256(abi.encode(_SETVALIDATOR_TYPEHASH, account, state, _getCrossDomain(), deadline));

    require(_verifySignature(publicKey, structHash, mgdSignature), "Invalid signature");

    _performL2Call(CrossAction.SetValidator, account, state, deadline, mgdSignature);
    _setValidator(account, state);
  }

  /**
   * @notice Similar to `whitelist()` with L2 synchronizaton.
   * @param account to set as validator
   * @param state to be set
   * @param deadline for the syncing to occur via this `signature`
   * @param mgdSignature generated from this `publicKey()`
   * @dev Requirements:
   * - `mgdSignature` should be generated by the `MintGoldDustCompany.publicKey()`
   * - This method should only be called from the L1 network
   */
  function whitelistWithL2Sync(
    address account,
    bool state,
    uint256 deadline,
    bytes calldata mgdSignature
  )
    external
    isValidatorOrOwner
    isZeroAddress(account)
  {
    _onlyMainnet();
    _checkDeadline(deadline, true);

    bytes32 structHash =
      keccak256(abi.encode(_WHITELIST_TYPEHASH, account, state, _getCrossDomain(), deadline));

    require(_verifySignature(publicKey, structHash, mgdSignature), "Invalid signature");

    _performL2Call(CrossAction.SetWhitelist, account, state, deadline, mgdSignature);
    _whitelist(account, state);
  }

  /**
   * @notice Receives a message from the L1 network and performs the action.
   * @param data received from the L1 network
   * @dev Requirements:
   * - This method should only be called from the L2 network by the `messenger`
   * - Verifies the `signature` of the `data` was signed by the `publicKey`
   * - The public keys in both networks should be the same
   */
  function receiveL1Sync(bytes memory data) external onlyCrossMessenger {
    _notMainnet();
    (CrossAction action, address account, bool state, uint256 deadline, bytes memory mgdSignature) =
      abi.decode(data, (CrossAction, address, bool, uint256, bytes));

    bool success;

    if (action == CrossAction.SetValidator) {
      bytes32 structHash =
        keccak256(abi.encode(_SETVALIDATOR_TYPEHASH, account, state, _getCrossDomain(), deadline));
      if (_verifySignature(publicKey, structHash, mgdSignature)) {
        _setValidator(account, state);
        success = true;
      }
    } else if (action == CrossAction.SetWhitelist) {
      bytes32 structHash =
        keccak256(abi.encode(_WHITELIST_TYPEHASH, account, state, _getCrossDomain(), deadline));
      if (_verifySignature(publicKey, structHash, mgdSignature)) {
        _whitelist(account, state);
        success = true;
      }
    }

    if (!success) {
      emit FailedReceiveL1Sync(action, account, state);
    }
  }

  /**
   * @notice Sets the cross domain messenger address between L1<>L2 or L2<>L1
   * @param newMessenger canonical address communicating between L1 or L2
   */
  function setMessenger(address newMessenger) external onlyOwner isZeroAddress(newMessenger) {
    messenger = ICrossDomainMessenger(newMessenger);
    emit SetMessenger(newMessenger);
  }

  /**
   * @notice Sets the cross domain MGDCompany address
   * @param chainId of domain
   * @param mgdCompany address of the L2 or L1 MGDCompany opposite to this.domain
   */
  function setCrossDomainMGDCompany(
    uint256 chainId,
    address mgdCompany
  )
    external
    override
    onlyOwner
    isZeroAddress(mgdCompany)
  {
    _setCrossDomainMGDCompany(chainId, mgdCompany);
  }

  function _performL2Call(
    CrossAction action,
    address account,
    bool state,
    uint256 deadline,
    bytes calldata mgdSignature
  )
    private
  {
    bytes memory message = abi.encodeWithSelector(
      this.receiveL1Sync.selector, abi.encode(action, account, state, deadline, mgdSignature)
    );
    address crosscompany = crossDomainMGDCompany();
    if (crosscompany == address(0)) {
      revert MgdCompanyL2Sync__performL2Call_noCrossDomainMGDCompany();
    }
    messenger.sendMessage(crosscompany, message, 1000000);
  }

  function _checkDeadline(uint256 deadline, bool withRevert) private {
    if (withRevert) {
      require(block.timestamp <= deadline, "Expired deadline");
    } else if (block.timestamp > deadline) {
      emit ExpiredDeadline(deadline);
    }
  }

  function _onlyMainnet() private view {
    if (block.chainid != _MAINNET_CHAINID) {
      revert MGDCompanyL2Sync__onlyMainnet();
    }
  }

  function _notMainnet() private view {
    if (block.chainid == _MAINNET_CHAINID) {
      revert MGDCompanyL2Sync__notOnMainnet();
    }
  }

  function _setValidator(address account, bool state) private {
    isAddressValidator[account] = state;
    emit ValidatorAdded(account, state);
  }

  function _whitelist(address account, bool state) private {
    isArtistApproved[account] = state;
    emit ArtistWhitelisted(account, state);
  }
}
